#define OS_CRYPT	/* Use OS supplied crypto random */
#define HW_RAND		/* code to use HW random */

#include <windows.h>
#include <conio.h>
#include <time.h>
#include <ctype.h>
#include <stdio.h>
#include "types.h"
#include "bigdeal.h"
#include "collect.h"
#include "os.h"

extern FILE *flog;

#ifdef OS_CRYPT

#include <Wincrypt.h>

/*
 * Let's get more bytes than needed. We actually only need 4/3*160 *bits*
 * which is 27 bytes. My trust in the OS is not high enough to dare that
 * currently
 */
#define N_OSC_BYTES 200

#ifdef HW_RAND

static HANDLE hSerial;

static int
open_serial_port (char *port)
{
    DCB dcbSerialParams = {0};
    COMMTIMEOUTS timeouts={0};

    hSerial = CreateFile(port, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
    if (hSerial == INVALID_HANDLE_VALUE) {
	return 0;
    }

    dcbSerialParams.DCBlength=sizeof(dcbSerialParams);
    if (!GetCommState(hSerial, &dcbSerialParams)) {
	 return 0;
    }
    dcbSerialParams.BaudRate=460800;
    dcbSerialParams.ByteSize=8;
    dcbSerialParams.StopBits=ONESTOPBIT;
    dcbSerialParams.Parity=NOPARITY;
    dcbSerialParams.fDtrControl = DTR_CONTROL_ENABLE;
    if(!SetCommState(hSerial, &dcbSerialParams)){
	 return 0;
    }

    timeouts.ReadIntervalTimeout=50;
    timeouts.ReadTotalTimeoutConstant=50;
    timeouts.ReadTotalTimeoutMultiplier=10;
    timeouts.WriteTotalTimeoutConstant=50;
    timeouts.WriteTotalTimeoutMultiplier=10;
    if(!SetCommTimeouts(hSerial, &timeouts)){
	return 0;
    }
    return 1;
}

static unsigned int
readFromSerialPort(char * buffer, int buffersize)
{
    unsigned int dwBytesRead = 0;
    if(!ReadFile(hSerial, (BYTE *) buffer, buffersize, (LPDWORD) &dwBytesRead, NULL)){
	return 0;
    }
    return dwBytesRead;
}
#endif

get_hwr
os_collect(char *hw_random)
{
    HCRYPTPROV   hCryptProv;
    BYTE         osrand[N_OSC_BYTES];

#ifdef HW_RAND
    if (hw_random) {
	char fname[100];
	BYTE *ptr;
	int nb, bytesread;

	if (*hw_random >= '0' && *hw_random <= '9') {
	    sprintf(fname, "\\\\.\\COM%s", hw_random);
	    hw_random = fname;
	}

	if(open_serial_port(hw_random)==0)
	    return 0;
	for (bytesread=1, ptr=osrand, nb=N_OSC_BYTES;
		bytesread>0 && nb > 0;
		ptr += bytesread, nb -= bytesread) {
	    bytesread = readFromSerialPort((char *) ptr, nb);
	}
	if (flog)
	    fprintf(flog, "Random sequence of %d bytes generated by HW\n", N_OSC_BYTES);
	/*
	 * Throw into entropy pool
	 * Guess four bits per byte, pessimistic
	 */
	collect_more((byte *) osrand, N_OSC_BYTES, 4*N_OSC_BYTES);
	return readFromSerialPort;
    }
#endif
    /*
     * Acquire a cryptographic provider context handle.
     */

    if(CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)) {    

	/*
	 * Generate a random initialization vector.
	 */

	if(CryptGenRandom(hCryptProv, N_OSC_BYTES, osrand)) {
	    if (flog)
		fprintf(flog, "Random sequence of %d bytes generated by OS\n", N_OSC_BYTES);
	    /*
	     * Throw into entropy pool
	     * Guess four bits per byte, pessimistic
	     */
	    collect_more((byte *) osrand, N_OSC_BYTES, 4*N_OSC_BYTES);
	}
    }
    return 0;
}
#else

get_hwr
os_collect() {
    int pid, getpid();

    collect_more((byte *) &frequency, sizeof(frequency), 0);
    collect_more((byte *) &epoch, sizeof(epoch), 8);
    pid = getpid();
    collect_more((byte *) &pid, sizeof(pid), 3);
    return 0;
}

#endif

static int highfreqclock;
static LARGE_INTEGER frequency, epoch;

void
os_start()
{

    /*
     * Start the clock running
     */
    if (QueryPerformanceFrequency(&frequency) == 0) {
	highfreqclock = 0;
    } else {
	highfreqclock = 1;
	QueryPerformanceCounter(&epoch);
	if (flog)
	    fprintf(flog, "Clock frequency %I64d, epoch %I64d\n",
		frequency.QuadPart, epoch.QuadPart);
    }
}

void
os_finish()
{

}

static int bestclock()
{
   LARGE_INTEGER t;

   if (highfreqclock) {
       QueryPerformanceCounter(&t);
       /* compute the elapsed time in ticks */
       return (t.QuadPart - epoch.QuadPart);
   }
#ifdef UCLOCKS_PER_SEC
    return (int) uclock();
#else
#ifdef CLOCKS_PER_SEC
    return (int) clock();
#else
There is no clock, this program needs it, so do not compile
#endif
#endif
}

#define MAX_INTERVAL_ENTROPY	6

int
getchtm(int *nbits)
/*
 * Read one character from standard input
 * Time the wait, and use bits for random
 * MUST be in cbreak mode for this to work
 */
{
    int t1, t2;
    int tdiff;
    int c;
    int shift;
    int b;

    /*
     * First get the best clock we have
     */
    t1 = bestclock();
    /*
     * Now get one character
     */
    c = getch();
    /*
     * If it is zero, which can happen with getch() under DOS
     * we have a two character sequence(function key probably)
     * and we make one character out of it by appending the next
     */
    if (c == 0)
	c = getch() + 256;
    /*
     * and get the clock after the keypress
     */
    t2 = bestclock();
    /*
     * Number of ticks we waited goes to tdiff
     */
    tdiff = t2 - t1;
    /*
     * Now we are going to believe half the bits we get
     */
    for (shift = tdiff, b = 0; shift>2 ; shift >>= 2, b++)
	;
    if (b < MAX_INTERVAL_ENTROPY)
	*nbits = b;
    else
	*nbits = MAX_INTERVAL_ENTROPY;
    /*
     * We send all the bits to the collect pool
     * but do not count the bits yet (parameter 0)
     * because higher layers might decide not to believe this
     * character, and its associated timing
     */
    collect_more((byte *) &t1, sizeof(t1), 0);
    collect_more((byte *) &t2, sizeof(t2), 0);

    if (flog)
	fprintf(flog, "Collected character %d, timediff %d, timebits %d\n",
	    c, tdiff, b);
    return c;
}

void
cbreak()
{

}

void
cooked()
{

}

int
legal_filename_prefix(char *s)
/*
 * Legal prefix to make legal name when three letter suffix added
 */
{

	if (*s == 0)	/* Too short */
		return 0;
	if (strlen(s) > 50)
		return 0;
	while (*s) {
		if (!isalnum(*s) && *s != '-' && *s != '_')
			return 0;
		s++;
	}
	return 1;
}

char *os_init_file_name()
{

	return "bigdeal.ini";
}
